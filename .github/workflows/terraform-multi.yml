name: terraform-multi

on:
  workflow_call:
    inputs:
      environment: { type: string, required: true }
      tfvars_file: { type: string, required: true }
      rgname: { type: string, required: true }
      saname: { type: string, required: true }
      scname: { type: string, required: true }
      key: { type: string, required: true }

      runInit:     { type: boolean, default: false }
      runFmt:      { type: boolean, default: false }
      runValidate: { type: boolean, default: false }
      runPlan:     { type: boolean, default: false }
      runApply:    { type: boolean, default: false }
      runDestroy:  { type: boolean, default: false }

      # ðŸ‘‡ NEW: caller decide karega env lagani hai ya nahi
      useEnvironment: { type: boolean, default: false }

      
    secrets:
      AZURE_CLIENT_ID:      { required: true }
      AZURE_TENANT_ID:      { required: true }
      AZURE_SUBSCRIPTION_ID: { required: true }

permissions: { id-token: write, contents: read }
jobs:
  init:
    if: ${{ inputs.runInit }}
    runs-on: self-hosted
    defaults: { run: { working-directory: infra } }
    steps:
      - uses: actions/checkout@v4
      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Terraform Init (backend)
        run: >
          terraform init -input=false
          -backend-config="resource_group_name=${{ inputs.rgname }}"
          -backend-config="storage_account_name=${{ inputs.saname }}"
          -backend-config="container_name=${{ inputs.scname }}"
          -backend-config="key=${{ inputs.key }}"

  fmt:
    if: ${{ inputs.runFmt }}
    needs: [init]
    runs-on: self-hosted
    defaults: { run: { working-directory: infra } }
    steps:
      - uses: actions/checkout@v4
      - run: terraform fmt -check -recursive || terraform fmt -recursive

  validate:
    if: ${{ inputs.runValidate }}
    needs: [init]    # fmt optional
    runs-on: self-hosted
    defaults: { run: { working-directory: infra } }
    steps:
      - uses: actions/checkout@v4
      - run: terraform validate

  plan:
    if: ${{ inputs.runPlan }}
    needs: [validate, init]
    runs-on: self-hosted
    defaults: { run: { working-directory: infra } }
    steps:
      - uses: actions/checkout@v4
      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Terraform Init (for plan)
        run: >
          terraform init -input=false
          -backend-config="resource_group_name=${{ inputs.rgname }}"
          -backend-config="storage_account_name=${{ inputs.saname }}"
          -backend-config="container_name=${{ inputs.scname }}"
          -backend-config="key=${{ inputs.key }}"
      - name: Terraform Plan
        run: terraform plan -var-file="../${{ inputs.tfvars_file }}" -out="plan-${{ inputs.environment }}.tfplan"
      - name: Upload plan bundle
        uses: actions/upload-artifact@v4
        with:
          name: tf-plan-${{ inputs.environment }}
          path: |
            infra/plan-${{ inputs.environment }}.tfplan
            infra/.terraform.lock.hcl
          if-no-files-found: error

# â”€â”€ APPLY (with environment) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
apply_env:
  needs: [plan, validate, fmt, init]
  if: ${{ always()
          && inputs.runApply
          && inputs.useEnvironment
          && (
               ( inputs.runPlan                                 && needs.plan.result     == 'success' ) ||
               ( !inputs.runPlan && inputs.runValidate          && needs.validate.result == 'success' ) ||
               ( !inputs.runPlan && !inputs.runValidate && inputs.runFmt && needs.fmt.result  == 'success' ) ||
               ( !inputs.runPlan && !inputs.runValidate && !inputs.runFmt && needs.init.result == 'success' )
             )
       }}
  runs-on: self-hosted
  environment: ${{ inputs.environment }}
  defaults: { run: { working-directory: infra } }
  steps: &apply_steps  # ðŸ‘ˆ is anchor ko reuse karenge
    - name: Checkout
      uses: actions/checkout@v4
    - name: Azure Login (OIDC)
      uses: Azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
    - name: Terraform Init (remote backend)
      run: |
        terraform init -input=false \
          -backend-config="resource_group_name=${{ inputs.rgname }}" \
          -backend-config="storage_account_name=${{ inputs.saname }}" \
          -backend-config="container_name=${{ inputs.scname }}" \
          -backend-config="key=${{ inputs.key }}"
    - name: Download plan
      uses: actions/download-artifact@v4
      with:
        name: tf-plan-${{ inputs.environment }}
        path: infra
    - name: Terraform apply
      run: terraform apply -auto-approve "plan-${{ inputs.environment }}.tfplan"

# â”€â”€ APPLY (without environment) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
apply_noenv:
  needs: [plan, validate, fmt, init]
  if: ${{ always()
          && inputs.runApply
          && !inputs.useEnvironment
          && (
               ( inputs.runPlan                                 && needs.plan.result     == 'success' ) ||
               ( !inputs.runPlan && inputs.runValidate          && needs.validate.result == 'success' ) ||
               ( !inputs.runPlan && !inputs.runValidate && inputs.runFmt && needs.fmt.result  == 'success' ) ||
               ( !inputs.runPlan && !inputs.runValidate && !inputs.runFmt && needs.init.result == 'success' )
             )
       }}
  runs-on: self-hosted
  defaults: { run: { working-directory: infra } }
  steps: *apply_steps   # ðŸ‘ˆ same steps, env key nahin


# â”€â”€ DESTROY (with environment) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
destroy_env:
  needs: [apply_env, apply_noenv, plan, validate, fmt, init]
  if: ${{ always()
          && inputs.runDestroy
          && inputs.useEnvironment
          && (
               ( inputs.runApply                                              && (needs.apply_env.result == 'success' || needs.apply_noenv.result == 'success') ) ||
               ( !inputs.runApply && inputs.runPlan                           && needs.plan.result     == 'success' ) ||
               ( !inputs.runApply && !inputs.runPlan && inputs.runValidate    && needs.validate.result == 'success' ) ||
               ( !inputs.runApply && !inputs.runPlan && !inputs.runValidate && inputs.runFmt && needs.fmt.result == 'success' ) ||
               ( !inputs.runApply && !inputs.runPlan && !inputs.runValidate && !inputs.runFmt && needs.init.result == 'success' )
             )
       }}
  runs-on: self-hosted
  environment: ${{ inputs.environment }}
  defaults: { run: { working-directory: infra } }
  steps: &destroy_steps
    - name: Checkout
      uses: actions/checkout@v4
    - name: Azure Login (OIDC)
      uses: Azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
    - name: Terraform Init (remote backend)
      run: |
        terraform init -input=false \
          -backend-config="resource_group_name=${{ inputs.rgname }}" \
          -backend-config="storage_account_name=${{ inputs.saname }}" \
          -backend-config="container_name=${{ inputs.scname }}" \
          -backend-config="key=${{ inputs.key }}"
    - name: Terraform destroy
      run: terraform destroy -auto-approve -var-file="../${{ inputs.tfvars_file }}"

# â”€â”€ DESTROY (without environment) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
destroy_noenv:
  needs: [apply_env, apply_noenv, plan, validate, fmt, init]
  if: ${{ always()
          && inputs.runDestroy
          && !inputs.useEnvironment
          && (
               ( inputs.runApply                                              && (needs.apply_env.result == 'success' || needs.apply_noenv.result == 'success') ) ||
               ( !inputs.runApply && inputs.runPlan                           && needs.plan.result     == 'success' ) ||
               ( !inputs.runApply && !inputs.runPlan && inputs.runValidate    && needs.validate.result == 'success' ) ||
               ( !inputs.runApply && !inputs.runPlan && !inputs.runValidate && inputs.runFmt && needs.fmt.result == 'success' ) ||
               ( !inputs.runApply && !inputs.runPlan && !inputs.runValidate && !inputs.runFmt && needs.init.result == 'success' )
             )
       }}
  runs-on: self-hosted
  defaults: { run: { working-directory: infra } }
  steps: *destroy_steps

